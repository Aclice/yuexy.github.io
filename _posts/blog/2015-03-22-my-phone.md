---
layout: post
title: 让电脑玩别踩白块
description: 当你有两台智商差距明显的设备的时候，它们基本上就可以自娱自乐了。（误
category: blog
---

这几天一直在看图像处理和机器视觉的东西，虽然效率奇低不过还是趁着hackday做了一个奇葩的小玩意，能让电脑通过摄像头看到手机玩别踩白块。 0 0 

所以虽然觉得很简单，但是作为自己图形处理的Hello World还是简单的说一下。

## 1、获取图像

因为是用了opencv，所以感觉获取图像没有啥好说的。略。

## 2、图像预处理

直接是用了电脑摄像头来获取图像，所以觉得图像的质量还是可以的，所以就没有降噪（个人觉得这里加上比较好）。这里是对原图像进行了两次不同的处理，分别就称为Mat1 & Mat2好了。

---

### Mat1

对于Mat1来说，首先用canny算法对边缘进行提取，然后直接用opencv自带的findContours函数来获取轮廓，在下表示并不知道opencv的findContours用了什么分割算法。

canny是对受白噪声影响的阶跃型边缘是最优的，貌似大家比较喜欢用的就是canny（不过起显示效果我还是更喜欢用Sobel导数查找边缘，这里先不说这个）。根据某本书上说的，canny的最优性与三个标准有关：

- 检测标准：不丢失重要的边缘，不应有虚假的边缘。
- 定位标准：实际边缘与检测到的边缘位置之间的误差最小。
- 单响应标准：将多个相应降低为单个边缘相应。其实这条跟前两条差不多，但是 比起单纯的用导数求的边缘来说，似乎是冗余的数据量少了不少。

至于算法。。。表示说公式太多真的好难写 = = ，果然是自己搭的blog局限性么。。嘛，不过这个算法应该是很好找，有兴趣的同学可以点[这里](www.google.com)。

之后获取轮廓的话就直接取外轮廓好了，因为对于别踩白块这种简单的画面来说，外轮廓基本就是手机屏幕啦。

获得轮廓之后，这里需要做一个假设，即，手机屏幕是摄像头画面中面积最大的轮廓。

嗯！对！没错，这里是偷懒的直接用了假！设！，并没有用机器识别是觉得手机画面的不确定性以及自己真的不会 = = ，所以直接是通过轮廓来获取一个最小的包围矩形，以及我也不知道这里是怎么个算法只知道是调用minAreaRect（Orz，所以这里，包围近似矩形的矩形当然就是手机屏幕大致的位置，get~

---

### Mat2

Mat2的处理就显得简单很多 = = ，直接二值化处理，因为Mat2的作用就是用来判断某个点的颜色，所以直接二值化去掉所有不是白色的颜色 =w= 。

## 3、获取位置并且模拟点击事件

已经获取到了手机屏幕的位置，只需要对这个区域进行一个简单的划分就可以轻松的得到每个方块的位置 0 0 ，然后在Mat2里进行取值判断，就可以get到黑块的位置（其实这里可以直接在Mat2中获取黑块的位置然后在Mat1中判断是否位于轮廓内）。

至于模拟点击事件嘛，最简单的方法就是直接调用adb shell命令。我的做法就是这种简单的 = = ，昂，，是adb shell input tap <x> <y> 。这样做会导致运行很慢，因为adb的速度真是，慢到不要不要的 = = ，所以只能玩经典模式还很慢。

什么？你说改进，昂~ 其实这里可以用socket来写个通讯，在安卓端要加一个Server来在本机模拟点击事件。当然实现方法比较多，可以用MotionEvent或者Instrumentation，这里实在是太懒了不想动手了 0w0 。

总之功能是已经实现了，可能会考虑后期的优化 0 0 。下面是图~

![EXAMPLE](../images/my_phone/white_block.jpg)